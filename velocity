#!/usr/bin/php
<?php

/**
 *	CONFIGURATION
 */
$config['daemon'] = ['host' => '127.0.0.1', 'port' => '8332']; // RPC for Bitcoin daemon
$config['daemon']['user'] = 'x'; // rpcuser
$config['daemon']['pass'] = 'x'; // rpcpassword
$config['avg_block_time'] = 600; // the daemon's avg block time in seconds
$config['min_sat_byte'] = 1; // minimum number of satoshis per byte to pay for transaction fees
$config['debug'] = false; // enable/disable extra debugging info
$config['add_op_return'] = false; // enable/disable random OP_RETURN data in txs to increase size by 80 ASCII bytes
$config['min_input_amount'] = 0.001; // minimum input size when splintering large inputs; default = 0.001


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

/**
 * 
 *			DO NOT EDIT ANYTHING BELOW UNLESS YOU KNOW WHAT YOU ARE DOING
 * 
 */
 

$v = new velocity($config);
while(true) {
	$v->init();
}
exit(0);

class velocity {
	const MIN_TX_AMOUNT = 0.00001000; // Minimum tx spend amount
	const MIN_TX_AGE = 25; // Minimum 0-conf tx age in seconds required before spend
	const VERSION = '0.3'; // optimized tx crafting logic
	// for tx calculations
	// Not using this because we aren't splitting the output amount between addresses
	// const TX_SPLIT_SWAY = 0.05; // 5% sway
	
	// Common properties
	private $daemon; // JSON-RPC connection to coin daemon
	private $height; // starting daemon block height
	private $height_time; // time we received latest daemon height
	private $unspent = []; // our wallet's unspent inputs (0+ confirmations)
	private $mempool = []; // numerical array of our daemon's mempool txids
	private $chains = []; // numerical array of transaction chains
	private $inputs = ['splintered' => [], 'to_splinter' => []]; // arrays of splintered and to-be-splintered inputs
	private $stats = [ // runtime stats counters
		'block' => 0, // current daemon height
		'blocks-seen' => 0, // blocks seen since start
		'chains' => 0, // num active chains (i.e. [...|input]->[output|input]->[output|...])
		'chains-inactive' => 0, // num chains w/ error and marked inactive
		'links' => 0, // number of links created during current round
		'links-confirmed' => 0, // total number of links confirmed by network
	];
	/**
	 * __construct(): Initiate the Velocity instance by applying user config and testing daemon RPC connection. Also set some properties
	 * 
	 * param (array) $config: User-defined config array
	 * 
	 */
	function __construct(array $config) {
		$this->config = $config;
		// Set version number
		$this->version = self::VERSION;
		// Connect to daemon
		$this->daemon = new coindaemon($this->config['daemon']['user'], $this->config['daemon']['pass'], $this->config['daemon']['host'], $this->config['daemon']['port']);
		if(!$this->check_daemon()) die ("[error] failed JSON-RPC connection to ".$this->config['daemon']['host'].':'.$this->config['daemon']['port']."\r\n*** reason: ".$this->daemon->error."\r\n");
		
		// initial property values
		$this->height = $this->daemon->getblockcount();
		// Set height time to best block's time
		$this->height_time = $this->get_last_block_time();
		// Debug mode?
		$this->debug = $this->config['debug'];
		// Don't allow more than 100 outputs when splintering an input
		$this->config['max_splinter_count'] = 100;
		// Don't allow <0.001 min_input_amt
		if($this->config['min_input_amount'] < 0.001) die("[error] min_input_amount of ".$this->config['min_input_amount']." must be greater than 0.001\r\n");
		
	}
	/**
	 * init(): Primary runtime function; executes the Velocity server
	 * 
	 * CTRL+C from the terminal anytime to stop the Velocity server
	 */
	function init() {
		
		$this->start_time = time();
		// Run until CTRL+C or other stop signal
		while(true) {
			// Verify daemon connection before proceeding with loop iteration
			if(!$this->check_daemon()) die("[error] JSON-RPC connection to ".$this->config['daemon']['host'].':'.$this->config['daemon']['port']." was lost.\r\n*** reason: ".$this->daemon->error."\r\n");
			
			/**
			 *		NEW BLOCK HANDLER
			 * 
			 */
			$this->update_block_height();
			
			/**
			 *		CONSOLE STATUS UPDATE
			 */
			$this->update_console();
			
			// Sleep for a sec before gathering and spending inputs
			// We sleep here so that links can be built and the loop iteration will
			// update the statistics above with those new links before the sleep reoccurs
			sleep(1);
			/**
			 *		BEGIN INPUTS ITERATION
			 * 
			 */
			// Get all confirmed and unconfirmed inputs
			$inputs = $this->get_unspent_inputs();
			if(!empty($inputs)) {
				for($i = 0; $i < count($inputs); $i++) {
					// Initialize new tx_craft array
					$this->tx_craft = [];
					// Set the current input
					$this->tx_craft['input'] = $input = $inputs[$i];
					
					// Continue to next input if splintered input is awaiting block confirmation
					if(in_array($input['txid'].':'.$input['vout'], $this->inputs['splintered'])) continue;
					
					// If this input is from an unconfirmed tx, we must reference its parent
					if($this->debug) echo "[debug] checking if input is from an unconfirmed tx...";
					$this->tx_craft['prevtxs'] = [];
					if($this->is_unconfirmed_input($i)) {
						if($this->debug) echo " YES; preparing prevtxs array...";
						$this->tx_craft['prevtxs'][] = $this->get_prevtx($input, $i);
						if($this->debug) echo " OK\r\n";
					} else if($this->debug) echo $this->chain_log_prefix." NO\r\n";
					
					
					/**
					 *		CHECK SPLINTER
					 * 
					 */
					// We must craft a special transaction for Splinter
					// We divide input amount by min_input_amount to create X number of outputs in a single tx
					// Then we set the new input inactive to await a new block for spending
					$this->tx_craft_getspendable();
					if($this->tx_craft['spendable'] > $this->config['min_input_amount']) {
						// Round up to nearest whole number.. last output receives remaining amount
						$num_outputs = ceil($this->tx_craft['spendable'] / $this->config['min_input_amount']);
						
						// Ensure only the max_splinter_count number of outputs, otherwise tx craft could fail
						if($num_outputs > $this->config['max_splinter_count']) $num_outputs = $this->config['max_splinter_count'];
						
						echo "\r\n*** large input detected; splintering into $num_outputs outputs...\r\n";
						
						for($j = 0; $j < $num_outputs; $j++) {
							$amount = ($j == ($num_outputs - 1) ? (float) $this->tx_craft['spendable'] - number_format($this->config['min_input_amount'] * ($num_outputs - 1), 8): $this->config['min_input_amount']);
							$this->tx_craft['outputs'][$this->daemon->getnewaddress()] = $amount;
						}
						
						$this->tx_craft_signrawtx();
						$this->tx_craft_adjustsignrawtx();
						
						$txid = $this->tx_craft_spend($ignore_chain = true);
						
						if($txid) {
							// After sending the tx, set each txid:vout in the inactive inputs array
							for($j = 0; $j < count($this->tx_craft['outputs']); $j++) {
								$this->inputs['splintered'][] = "$txid:$j";
							}
							
						} else {
							// if tx failed to send, set the input inactive and wait for next block
							$this->inputs['to_splinter'][] = $this->tx_craft['input']['txid'].':'.$this->tx_craft['input']['vout'];
						}
						
						// continue to next input loop iteration
						if($this->update_block_height()) continue 2;
						$this->update_console();
						usleep(mt_rand(65000,115000));
						continue;
					}
					
					
					/**
					 *		CHECK INPUTS
					 * 
					 */
					
					// If this input has not yet been chained, we start a new chain
					if($this->debug) echo "[debug] checking if input ".($i + 1)." is chained...";
					if(($chain_index = $this->is_chained_input($input)) === false) {
						if($this->debug) echo " NO; initializing new chain\r\n";
						// put new chain on front of chains array; chain index is 0
						array_unshift($this->chains, $this->new_chain($input));
						$chain_index = 0;
					} else if($this->debug) echo " YES; initializing existing chain\r\n";
					
					// Set the chain var as current chain index
					$chain = $this->chains[$chain_index];
					$num_chains = count($this->chains);
					$this->chain_log_prefix = $chain_log_prefix = "[debug] [chain ".($chain_index + 1)."/$num_chains]";
					
					// If the chain has been marked inactive, continue to next chain
					if($this->debug) echo $chain_log_prefix." checking if chain is active...";
					if(!$chain['state']['active']) {
						if($this->debug) echo " NO; continuing to next chain...\r\n";
						continue;
					} else if($this->debug) echo " YES\r\n";
					$chain['state']['active'] = true;
					
					// Only proceed if input is also ready to spend
					if($this->debug) echo $chain_log_prefix." checking if chain tip is ready to spend...";
					if($this->is_input_ready($chain['tip'])) {
						if($this->debug) echo " YES\r\n";
						
						/**
						 *		TRANSACTION CRAFTING
						 * 
						 */
						$steps = [
							// 'getspendable', // we get this before checking Splinter
							'getoutputs',
							'signrawtx',
							'adjustsignrawtx',
							// 'spend' // don't send the tx inside the while() loop.. only craft the tx
						];
						
						// Once the tx is crafted, we exit the while() loop to spend the tx
						$tx_crafted = false;
						$step = current($steps);
						while($tx_crafted === false) {
							$function = 'tx_craft_'.$step;
							$this->$function();
							
							// If last step, tx is crafted
							// otherwise proceed to next step
							if($step == $steps[count($steps) - 1]) $tx_crafted = true;
							else $step = next($steps);
						}
						
						/**
						 *		SPEND THE CRAFTED TX :)
						 * 
						 *		ERROR HANDLING + CLEANUP INCLUDED
						 * 
						 */
						$this->tx_craft_spend($ignore_chain = false, $chain, $chain_index);
						
						// Check for new block
						if($this->update_block_height()) continue 2;
						$this->update_console();
						// Continue the inputs loop after a random wait
						usleep(mt_rand(65000,115000));
						continue;
						
					} else if($this->debug) echo " NO; continuing...\r\n";
				}
			} else if($this->debug) echo "[main] no inputs to spend...\r\n";
		}
	}
	/**
	 * check_daemon(): Checks to ensure connectivity to daemon is OK
	 * 
	 * return (bool): True if daemon is alive, false otherwise
	 */
	function check_daemon() {
		// Do a simple getblockcount() to ensure daemon responds
		return (bool) $this->daemon->getblockcount();
	}
	
	function update_runtime_stats() {
		$this->stats['block'] = $this->height;
		$this->stats['unspent'] = count($this->unspent);
		
		$states = $this->get_all_chain_states();
		$this->stats['chains'] = $states['active'];
		$this->stats['chains-inactive'] = $states['inactive'];
		
		$this->stats['links'] = ($links = $this->get_link_count());
	}
	
	function update_block_height() {
		
		// Update block height
		$this->prev_height = $this->height;
		$this->height = $this->daemon->getblockcount();
		if($this->height > $this->prev_height) {
			// Set current time of block height
			$this->height_time = $this->get_last_block_time();
			// Increment blocks seen stat
			$this->stats['blocks-seen'] += 1;
			// Add prev links to confirmed count
			$this->stats['links-confirmed'] += $this->stats['links'];
			// Reset all chains after new block; start with fresh tx chains
			$this->chains = [];
			
			// Reset the inactive and disabled inputs since new block means they are ready to chain
			$this->inputs['splintered'] = [];
			$this->inputs['to_splinter'] = [];
			
			return true;
			
		}
		
		return false;
	}
	
	function update_console() {
		// Need to update stats first
		$this->mempool = $this->daemon->getmempoolinfo();
		$this->update_runtime_stats();
		// clear and print to screen
		system('clear');
		echo "\r\n";
		echo "\tVelocity, for cryptocurrencies (v".$this->version.")\r\n";
		echo "\trunning since ".date('m/d/Y H:i:s', $this->start_time)."\r\n";
		echo "\r\n";
		echo '[main] round '.($this->stats['blocks-seen'] + 1).': { block:'.$this->stats['block'].$this->show_block_time_indicator().'  chains:'.number_format($this->stats['chains']).'  links:'.number_format($this->stats['links']).'  links-confirmed:'.number_format($this->stats['links-confirmed'])." }\r\n";
		echo '[main] mempool: { tx-count:'.$this->mempool['size'].'  total-size:'.number_format($this->mempool['bytes']).' bytes  ram:'.number_format($this->mempool['usage'])." bytes }\r\n";
		// If there are any inactive chains, show how many in the console
		if($this->stats['chains-inactive'] > 0) {
			echo "\r\n*** ".$this->stats['chains-inactive']." chains are inactive due to error\r\n";
			if($this->debug) {
				// additional debug info
			}
		}
		// If any inputs are currently pending a block confirmation, show how many in the console
		if($num_splintered = count($this->inputs['splintered']) > 0) {
			echo "\r\n*** $num_splintered splintered input(s) will be chained after new block\r\n";
			if($this->debug) {
				// additional debug info
			}
		}
		
		if($num_to_splinter = count($this->inputs['to_splinter']) > 0) {
			echo "\r\n*** $num_to_splinter large input(s) will be splintered after new block\r\n";
			if($this->debug) {
				// additional debug info
			}
		}
		
	}
	/**
	 * new_chain(): Create new chain array with the provided input $txid:$vout
	 * 
	 * @param (array) $input: the 'txid' and 'vout' of the input for which to create the new chain
	 * 
	 * return (array):new chain's "genesis" link
	 */
	function new_chain(array $input) {
		return [
			'tip' => [
				'txid' => $input['txid'].':'.$input['vout'],
				'time' => time() - (self::MIN_TX_AGE + 1),
				'genesis' => true
			],
			'links' => [],
			'state' => ['active' => true],
			'error' => [
				'string' => '',
				'height' => 0
			]
		];
	}
	/**
	 * is_chain_error(): Checks the chain state at given index to ensure it is ready to be extended
	 * 
	 * return (bool): true is returned if the chain has an error, false otherwise
	 */
	function is_chain_error(array $chain) {
		// Set up handlers to modify chain state as needed
		switch(!false) {
			// chain is ready if already set or if chain tip is genesis
			case isset($chain['tip']['genesis']):
				return false;
			
			// 25-descendant limit on unconfirmed tx
			case strpos($chain['error']['string'], 'too-long-mempool-chain'):
				// reset chain state if new block has been found
				if($this->height > $chain['error']['height'])
					return false;
					
			// Assume chain is in error (and should be deactivated) if no above handler matched
			default:
				return true;
		}
	}
	
	function get_last_block_time() {
		$block = $this->daemon->getblock($this->daemon->getbestblockhash());
		return $block['time'];
	}
	
	function show_block_time_indicator() {
		if(time() - $this->height_time < (0.10 * $this->config['avg_block_time'])) return '(!)'; // new/recent block!
		elseif(time() - $this->height_time > $this->config['avg_block_time']) return '(?)'; // where is the next block?
		
		// If not matched, return empty string
		return '';
	}
	
	function get_all_chain_states() {
		$active = 0;
		$inactive = 0;
		for($i = 0; $i < count($this->chains); $i++) {
			$this->chains[$i]['state']['active'] ? $active += 1: $inactive += 1;
		}
		
		return ['active' => $active, 'inactive' => $inactive];
	}
	
	function get_link_count() {
		$num_links = 0;
		for($i = 0; $i < count($this->chains); $i++) {
			$num_links += count($this->chains[$i]['links']);
		}
		
		return $num_links;
	}
	
	function get_prevtx(array $input, $index = 0) {
		// decode the utxo
		$decoded_input = $this->daemon->decoderawtransaction(
			$this->daemon->getrawtransaction($input['txid'])
		);
		// for each output in current utxo...
		for($i = 0; $i < count($decoded_input['vout']); $i++) {
			$vout = $decoded_input['vout'][$i];
			// loop through unspent at $index
			for($j = $index; $j < count($this->unspent); $j++) {
				if(
					$this->unspent[$index]['amount'] == $vout['value'] &&
					$this->unspent[$index]['vout'] == $vout['n']
				) {
					return [
						'txid' => $this->unspent[$index]['txid'],
						'vout' => $this->unspent[$index]['vout'],
						'scriptPubKey' => $this->unspent[$index]['scriptPubKey'],
						'amount' => (float) $this->unspent[$index]['amount']
					];
				}
				
			}
			
		}
	}
	
	function is_chained_input(array $input) {
		// For each chain
		for($i = 0; $i < count($this->chains); $i++) {
			$chain = $this->chains[$i];
			// Check chain's most recent txid first
			if($chain['tip']['txid'] == $input['txid'].':'.$input['vout']) return $i;
			// Then check chain's history
			for($j = 0; $j < count($chain['links']); $j++) {
				$spent = $chain['links'][$j];
				// Match txid
				if($spent['txid'] == $input['txid'].':'.$input['vout']) return $i;
			}
		}
		// input not chained
		return false;
	}
	/**
	 * True if input has less than 1 network confirmation
	 */
	function is_unconfirmed_input(int $index) {
		return (bool) ($this->unspent[$index]['confirmations'] < 1);
	}
	/**
	 * is_input_ready(): Checks to determine where the tip of a particular chain is ready to spend
	 * 
	 * @param (array) $chain_tip: array containing all chain tip info (txid:vout, time, prevtxs, etc)
	 * 
	 * return (bool): True if chain tip is ready to spend, false otherwise
	 */
	function is_input_ready(array $chain_tip) {
		
		// Input is ready if it is of the minimum age for newly-created inputs
		$ready = (bool) (time() > ($chain_tip['time'] + self::MIN_TX_AGE));
		
		return $ready;
	}
	/**
	 * Returns inputs in [{"txid":"abcdef012...","vout":n},{...}] structure
	 */
	function get_unspent_inputs() {
		// Verify daemon connection
		if(!$this->check_daemon()) die("[error] failed to connect to daemon; exiting...\r\n");
		
		// Get unspent inputs
		$this->unspent = $this->daemon->listunspent($minconf = 0);
		
		$inputs = [];
		for($i = 0; $i < count($this->unspent); $i++) {
			$inputs[$i] = [
				'txid' => $this->unspent[$i]['txid'],
				'vout' => $this->unspent[$i]['vout']
			];
		}
		
		return $inputs;
	}
	
	function tx_craft_getspendable() {
		$this->tx_craft['spendable'] = $spendable = $this->get_spendable($this->tx_craft['input']);
		if($this->debug) echo $this->chain_log_prefix." spendable amount:\t$spendable\r\n";
	}
	
	function tx_craft_getoutputs() {
	
		// Set up outputs to distribute coin(s)
		if($this->debug) echo $this->chain_log_prefix." preparing outputs...";
		$this->tx_craft['outputs'] = [$this->daemon->getnewaddress() => $this->tx_craft['spendable']];
		if($this->debug) echo " OK\r\n";
		
		if($this->config['add_op_return']) {
			if($this->debug) echo $this->chain_log_prefix." adding random OP_RETURN data to tx output...";
			$this->tx_craft['outputs']['data'] = gen_tx_data();
			if($this->debug) echo " OK\r\n";
		}
		
	}
	
	function tx_craft_signrawtx() {
		// Create + sign new tx with above inputs/outputs
		if($this->debug) echo $this->chain_log_prefix." signing initial tx...";
		if(!$this->tx_craft['signed_tx'] = $this->daemon->signrawtransaction(
			$this->tx_craft['raw_tx'] = $this->daemon->createrawtransaction([$this->tx_craft['input']], $this->tx_craft['outputs']), $this->tx_craft['prevtxs']
		)) { die($this->debug ? " FAIL\r\n": "[error] first createrawtransaction RPC call failed\r\n".' *** reason:'.$this->daemon->error."\r\n *** raw_tx:".json_encode($this->tx_craft['raw_tx'])."\r\n"); }
		else { if($this->debug) echo " OK\r\n"; }
	}
	
	function tx_craft_adjustsignrawtx() {
		// Adjust fee on signed tx and create new signed tx
		if($this->debug) echo $this->chain_log_prefix." signing new tx with fee adjustment...";
		if(!$this->tx_craft['signed_tx'] = $this->daemon->signrawtransaction(
			$this->adjust_for_fee($this->tx_craft['signed_tx'], [$this->tx_craft['input']], $this->tx_craft['outputs']), $this->tx_craft['prevtxs']
		)) { die($this->debug ? " FAIL\r\n": "[error] second createrawtransaction RPC call failed\r\n".' *** reason:'.$this->daemon->error."\r\n *** raw_tx:".json_encode($this->tx_craft['raw_tx'])."\r\n"); }
		else { if($this->debug) echo " OK\r\n"; }
	}
	
	function tx_craft_spend(bool $ignore_chain, array $chain = [], int $chain_index = -1) {
		if($this->debug) echo $this->chain_log_prefix." sending tx...";
		$txid = $this->daemon->sendrawtransaction($this->tx_craft['signed_tx']['hex']);
		if($txid) {
			if($this->debug) echo " OK\r\n";
			if($this->debug) echo $this->chain_log_prefix." tx:$txid\r\n";
		}
		else {
			if($this->debug) echo "FAIL\r\n[error] ".$this->daemon->error."\r\n";
			else echo "[error] ".$this->chain_log_prefix." ".$this->daemon->error."\r\n";
		}
		
		// assuming we are processing chain state following the tx spend...
		if(!$ignore_chain) {
			// Handle any daemon errors if present
			$error = false;
			if($e = $this->daemon->error) {
				// Since input wasn't spent, we leave chain tip as-is and
				// only update the state accordingly
				$chain['error']['string'] = $e;
				$chain['error']['height'] = $this->height;
				$chain['state']['active'] = false;
				// $chain['state']['ready'] = false;
				
				// Update chains array with latest chain data
				$this->chains[$chain_index] = $chain;
				
				// Houston, we have a spending error
				$error = true;
			}
			
			// Update chain info if we haven't received a spending error
			if(!$error) {
				// Move the spent input to the links array
				array_unshift($chain['links'], $chain['tip']);
				// Update chain tip with latest input
				$chain['tip'] = [
					'txid' => "$txid:0", // always set first output since only 1 rcpt
					'time' => time(),
					'input_used' => [
						'txid' => $this->tx_craft['input']['txid'],
						'vout' => $this->tx_craft['input']['vout']
					]
				];
				
				// Update chains array with latest chain data
				$this->chains[$chain_index] = $chain;
			}
			
		}
		
		return $txid;
		
	}
	
	function adjust_for_fee($signed_tx, array $inputs, array $outputs) {
		$decoded_tx = $this->daemon->decoderawtransaction($signed_tx['hex']);
		
		// loop through vouts backwards to adjust last eligible output
		for($i = count($decoded_tx['vout']) - 1; $i >= 0; $i--) {
			$vout = $decoded_tx['vout'][$i];
			if(isset($vout['scriptPubKey']['addresses'])) {
				$amount = (float) ($vout['value'] - number_format(($decoded_tx['size'] / 100000000) * $this->config['min_sat_byte'], 8));
				// Only change the output if the amount is greater than 0 after adjusting for fee
				if($amount > 0) {
					$outputs[$vout['scriptPubKey']['addresses'][0]] = $amount;
					return $this->daemon->createrawtransaction($inputs, $outputs);
				}
			}
		}
		
		// If we haven't yet returned, assume we cannot pay for the tx
		return false;
		
	}
	
	/*
	function setup_outputs(float $spendable) {
		$num_rcpts = 1; //mt_rand(1, 2);
		
		for($i = 0; $i < $num_rcpts; $i++)
			$addresses[] = $this->daemon->getnewaddress();
		
		$percent_allocated = 0.00; // 1.00 = 100%
		$outputs = [];
		for($i = 0; $i < count($addresses); $i++) {
			$i + 1 == count($addresses) ?
				$percentage = number_format(1.0000 - $percent_allocated, 4):
				$percentage = number_format(mt_rand(((1 / $num_rcpts) - self::TX_SPLIT_SWAY)*10000, ((1 / $num_rcpts) + self::TX_SPLIT_SWAY)*10000) / 10000, 4);
			
			$outputs[$addresses[$i]] = (float) number_format($spendable * $percentage, 8);
			$percent_allocated += $percentage;
		}
		
		return $outputs;
		
	}
	*/
	/**
	 * get_spendable(): Gets total spendable amount of specific vout in input
	 * 
	 * @param (array) $input: input txid/vout array
	 * 
	 * return (float): returns the input'ss vout value
	 */
	function get_spendable(array $input) {
		$decoded_tx = $this->daemon->decoderawtransaction(
			$this->daemon->getrawtransaction($input['txid'])
		);
		
		return (float) $decoded_tx['vout'][$input['vout']]['value'];
		
	}
	/**
	 * rand_wait(): Block loop iterations for a random amount of time
	 */
	function rand_wait() {
		usleep(mt_rand(350000, 635000));
	}
	
}

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

/*
EasyBitcoin-PHP
A simple class for making calls to Bitcoin's API using PHP.
https://github.com/aceat64/EasyBitcoin-PHP
====================
The MIT License (MIT)
Copyright (c) 2013 Andrew LeCody
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
====================
// Initialize Bitcoin connection/object
$bitcoin = new Bitcoin('username','password');
// Optionally, you can specify a host and port.
$bitcoin = new Bitcoin('username','password','host','port');
// Defaults are:
//	host = localhost
//	port = 8332
//	proto = http
// If you wish to make an SSL connection you can set an optional CA certificate or leave blank
// This will set the protocol to HTTPS and some CURL flags
$bitcoin->setSSL('/full/path/to/mycertificate.cert');
// Make calls to bitcoind as methods for your object. Responses are returned as an array.
// Examples:
$bitcoin->getinfo();
$bitcoin->getrawtransaction('0e3e2357e806b6cdb1f70b54c3a3a17b6714ee1f0e68bebb44a74b1efd512098',1);
$bitcoin->getblock('000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f');
// The full response (not usually needed) is stored in $this->response
// while the raw JSON is stored in $this->raw_response
// When a call fails for any reason, it will return FALSE and put the error message in $this->error
// Example:
echo $bitcoin->error;
// The HTTP status code can be found in $this->status and will either be a valid HTTP status code
// or will be 0 if cURL was unable to connect.
// Example:
echo $bitcoin->status;
*/
//class Bitcoin
class coindaemon
{
    // Configuration options
    private $username;
    private $password;
    private $proto;
    private $host;
    private $port;
    private $url;
    private $CACertificate;
    // Information and debugging
    public $status;
    public $error;
    public $raw_response;
    public $response;
    private $id = 0;
    /**
     * @param string $username
     * @param string $password
     * @param string $host
     * @param int $port
     * @param string $proto
     * @param string $url
     */
    public function __construct($username, $password, $host = 'localhost', $port = 8332, $url = null)
    {
        $this->username      = $username;
        $this->password      = $password;
        $this->host          = $host;
        $this->port          = $port;
        $this->url           = $url;
        // Set some defaults
        $this->proto         = 'http';
        $this->CACertificate = null;
    }
    /**
     * @param string|null $certificate
     */
    public function setSSL($certificate = null)
    {
        $this->proto         = 'https'; // force HTTPS
        $this->CACertificate = $certificate;
    }
    public function __call($method, $params)
    {
        $this->status       = null;
        $this->error        = null;
        $this->raw_response = null;
        $this->response     = null;
        // If no parameters are passed, this will be an empty array
        $params = array_values($params);
        // The ID should be unique for each call
        $this->id++;
        // Build the request, it's ok that params might have any empty array
        $request = json_encode(array(
            'method' => $method,
            'params' => $params,
            'id'     => $this->id
        ));
        // Build the cURL session
        $curl    = curl_init("{$this->proto}://{$this->host}:{$this->port}/{$this->url}");
        $options = array(
            CURLOPT_HTTPAUTH       => CURLAUTH_BASIC,
            CURLOPT_USERPWD        => $this->username . ':' . $this->password,
            CURLOPT_RETURNTRANSFER => true,
            CURLOPT_FOLLOWLOCATION => true,
            CURLOPT_MAXREDIRS      => 10,
            CURLOPT_HTTPHEADER     => array('Content-type: application/json'),
            CURLOPT_POST           => true,
            CURLOPT_POSTFIELDS     => $request
        );
        // This prevents users from getting the following warning when open_basedir is set:
        // Warning: curl_setopt() [function.curl-setopt]:
        //   CURLOPT_FOLLOWLOCATION cannot be activated when in safe_mode or an open_basedir is set
        if (ini_get('open_basedir')) {
            unset($options[CURLOPT_FOLLOWLOCATION]);
        }
        if ($this->proto == 'https') {
            // If the CA Certificate was specified we change CURL to look for it
            if (!empty($this->CACertificate)) {
                $options[CURLOPT_CAINFO] = $this->CACertificate;
                $options[CURLOPT_CAPATH] = DIRNAME($this->CACertificate);
            } else {
                // If not we need to assume the SSL cannot be verified
                // so we set this flag to FALSE to allow the connection
                $options[CURLOPT_SSL_VERIFYPEER] = false;
            }
        }
        curl_setopt_array($curl, $options);
        // Execute the request and decode to an array
        $this->raw_response = curl_exec($curl);
        $this->response     = json_decode($this->raw_response, true);
        // If the status is not 200, something is wrong
        $this->status = curl_getinfo($curl, CURLINFO_HTTP_CODE);
        // If there was no error, this will be an empty string
        $curl_error = curl_error($curl);
        curl_close($curl);
        if (!empty($curl_error)) {
            $this->error = $curl_error;
        }
        if ($this->response['error']) {
            // If bitcoind returned an error, put that in $this->error
            $this->error = $this->response['error']['message'];
        } elseif ($this->status != 200) {
            // If bitcoind didn't return a nice error message, we need to make our own
            switch ($this->status) {
                case 400:
                    $this->error = 'HTTP_BAD_REQUEST';
                    break;
                case 401:
                    $this->error = 'HTTP_UNAUTHORIZED';
                    break;
                case 403:
                    $this->error = 'HTTP_FORBIDDEN';
                    break;
                case 404:
                    $this->error = 'HTTP_NOT_FOUND';
                    break;
            }
        }
        if ($this->error) {
            return false;
        }
        return $this->response['result'];
    }
}

// Misc functions
function gen_tx_data() {
	$strlen = 80; // this is max w/o node reject
	$charset = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./';
	
	$string = '';
	for($i = 0; $i < $strlen; $i++) {
		$string .= $charset[mt_rand(0, strlen($charset) - 1)];
	}
	// tx data must be hex!
	return bin2hex($string);
}

?>
